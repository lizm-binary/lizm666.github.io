<!DOCTYPE html>
<html lang="zh">
<!--[if IE 8]>
<html class="no-js lt-ie9" lang="zh">
<![endif]-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta http-equiv="Pragma" content="no-cache" />
    <meta name="description" content="">
    <meta name="keywords" content="">
    <title>深入理解ES6（三）</title>
    <link rel="stylesheet" href="/lib/animate.css/animate.css">
    <link rel="stylesheet" href="/assets/css/md-wrap.css">
    <link rel="stylesheet" href="/assets/css/styles.css">
</head>
<body>

<div class="nav">
	<div style="display: inline-block;float: left;margin-left: 80px;height: 80px;line-height: 80px;color: #fff;font-size: 22px;">
		广告位招租
	</div>
    <ul>
        
        <li><a href="/" >Home</a></li>
        
        <li><a href="/about.html" >About</a></li>
        
    </ul>
</div>
<!DOCTYPE html>
<html lang="zh">
<!--[if IE 8]>
<html class="no-js lt-ie9" lang="zh">
<![endif]-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta http-equiv="Pragma" content="no-cache" />
    <meta name="description" content="">
    <meta name="keywords" content="">
    <title>Title</title>
    <link rel="stylesheet" href="">
</head>
<body>


<script src=""></script>
</body>

<div class="container">
    <div class="post bounceInUp animated">
        <div class="header">
            <div class="title">深入理解ES6（三）</div>
            <div class="info">
                <span class="view-count">192</span>
                <span class="dot">·</span>
                <span class="date">2019-09-30</span>
                <span class="dot">·</span>
                <span class="author">lizm</span>
            </div>
        </div>
        
<div class="music-box">
    <div class="music-name-author">
        ♬：<span>岁月神偷-金玟岐</span>
    </div>
    <video controls="" autoplay="" name="media" loop="">
        <source src="http://127.0.0.1:4000/assets/music/suiyueshentou.m4a" type="audio/mp4">
    </video>
</div>

        <div class="content post-content"><p>ES6的注意点和一些使用技巧总结，第三篇包括JavaScript 中的类（Class），Promise 与异步编程，代理（Proxy）。</p>

<h3>1. JavaScript 中的类（Class）</h3>

<ul>
  <li>
    <p>ES5中的近类结构</p>

    <blockquote>
      <p>在ES5以及早期版本中没有类的概念，最相近的思路是创建一个自定义类型：首先创建一个构造函数，然后定义一个方法并赋值给构造函数的原型。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">PersonType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">PersonType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PersonType</span><span class="p">(</span><span class="s1">'Nicholas'</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">// "Nicholas"</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span> <span class="k">instanceof</span> <span class="nx">PersonType</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>

    <blockquote>
      <p>许多模拟类的JS库都是基于这个模式开发的，ES6也是借鉴了类似的方法。</p>
    </blockquote>
  </li>
  <li>
    <p>类的声明</p>

    <blockquote>
      <p>使用关键字 class 后面紧跟类的名字，然后加上花括号{}，{}内是类的具体实现，其语法类似于对象字面量方法，只是各元素之间不再需要使用逗号分隔。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">PersonClass</span> <span class="p">{</span>
      
  <span class="c1">// 相当于ES5中 PersonType 的构造函数</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="c1">// 相当于ES5中 PersonType.prototype.sayName</span>
  <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <blockquote>
      <p>私有属性是实例中的属性，不会出现在原型上，且只有在类的构造函数或者方法中创建，上面的name就是一个私有属性。一般建议在构造函数里面创建好所有的私有属性，方便只在一个地方统一管理所有的私有属性。</p>
    </blockquote>

    <blockquote>
      <p>事实上，类的声明只是基于已有自定义类型声明的语法糖。但是与函数不同的是，类属性不可以被赋予新的值。</p>
    </blockquote>
  </li>
  <li>
    <p>为什么要使用类语法</p>

    <blockquote>
      <p>尽管类声明和自定义类型之间有很多相似的地方，但我们仍然需要记住下面这些区别：</p>
    </blockquote>

    <ul>
      <li>
        <p>函数声明可以被提升，但是类声明不能被提升，真正执行声明语句之前，它们会一直处在临时死区内。</p>
      </li>
      <li>
        <p>类声明中的说有代码都将自动在严格模式下执行，且无法强制让代码脱离严格模式。</p>
      </li>
      <li>
        <p>在类中所有的方法都是不可枚举的，但是在自定义类型中，可以通过Object.defineProperty()方法手工设置某个方法是否可枚举。</p>
      </li>
      <li>
        <p>每个类都有一个名为[[Construct]]的内部方法，通过关键字new调用那些不含[[Construct]]的方法时，程序将抛出错误。</p>
      </li>
      <li>
        <p>使用出关键字new之外的方式调用类的构造函数，会导致程序报错。</p>
      </li>
      <li>
        <p>在类中修改类名，程序会报错。</p>
      </li>
    </ul>

    <blockquote>
      <p>虽然不能在类的方法中修改类名，但是可以在外部修改。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(){</span>
      <span class="nx">Foo</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span> <span class="c1">// 程序报错</span>
    <span class="p">}</span>
  <span class="p">}</span>
    
  <span class="nx">Foo</span> <span class="o">=</span> <span class="s1">'biz'</span><span class="p">;</span> <span class="c1">// 可以修改</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>类表达式</p>

    <blockquote>
      <p>除了可以声明一个类，还可以使用表达式来创建，就像创建一个函数一样。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">PersonClass</span> <span class="o">=</span> <span class="kd">class</span><span class="p">{</span>
  <span class="c1">// 内部实现一致</span>
<span class="p">}</span>
    
</code></pre></div>    </div>
    <blockquote>
      <p>也可以创建一个具名类。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">PersonClass</span> <span class="o">=</span> <span class="kd">class</span> <span class="nx">PersonClass2</span> <span class="p">{</span>
  <span class="c1">//内部实现一致</span>
<span class="p">};</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">PersonClass2</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div>    </div>

    <blockquote>
      <p>类表达式同样不会被提升，匿名类表达式的name属性是一个空字符串，但是类声明的name属性值是类名。具名类表达式中，类的名称只能在类的内部使用。</p>
    </blockquote>
  </li>
  <li>
    <p>作为一等公民的类</p>

    <blockquote>
      <p>在程序中，一等公民是指一个可以传入函数，可以从函数返回，并且可以赋值给变量的值。JS函数就是一等公民，类也是一等公民。ES6中依然保持了类的一等公民身份，允许通过多种方式使用类的特性。</p>
    </blockquote>

    <ul>
      <li>
        <p>类作为参数传入函数中</p>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createObject</span><span class="p">(</span><span class="nx">classDef</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">classDef</span><span class="p">();</span>
<span class="p">}</span>
        
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">createObject</span><span class="p">(</span><span class="kd">class</span> <span class="p">{</span>

  <span class="nx">sayHi</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Hi!'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
        
<span class="nx">obj</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span>  <span class="c1">// 'Hi!'</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>通过立即调用类的构造函数来创建单例</p>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="kd">class</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">sayName</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}(</span><span class="s1">'Nicholas'</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//'Nicholas' </span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>访问器属性</p>

    <blockquote>
      <p>尽管应该在类构造函数中创建自己的属性，但是类也支持直接在原型上定义访问器属性（getter 和 setter）。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">CustomHTMLElement</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">el</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">el</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kd">get</span> <span class="nx">html</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kd">set</span> <span class="nx">html</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">CustomHTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">'html'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"get"</span> <span class="k">in</span>  <span class="nx">descriptor</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"set"</span> <span class="k">in</span>  <span class="nx">descriptor</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span><span class="p">);</span> <span class="c1">// false</span>
</code></pre></div>    </div>

    <blockquote>
      <p>使用非类形式实现会比使用类实现要复杂些</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">CustomHTMLElement</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="s2">"use strict"</span><span class="p">;</span>
      
  <span class="kd">const</span> <span class="nx">CustomHTMLElement</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="s2">"undefined"</span><span class="p">){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"必须通过关键字new调用构造函数"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">CustomHTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span><span class="s2">"html"</span><span class="p">,{</span>
    <span class="na">enumerable</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">get</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHtml</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="na">set</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHtml</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
    
  <span class="k">return</span> <span class="nx">CustomHTMLElement</span><span class="p">;</span>
<span class="p">}());</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>可计算成员名称（属性名或者方法名是一个变量）</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 方法名是一个变量</span>
    
<span class="kd">let</span> <span class="nx">methodName</span> <span class="o">=</span> <span class="s1">'sayName'</span><span class="p">;</span>
    
<span class="kd">class</span> <span class="nx">PersonClass</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">[</span><span class="nx">methodName</span><span class="p">](){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PersonClass</span><span class="p">(</span><span class="s1">'Nicholas'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="nx">sayName</span><span class="p">());</span> <span class="c1">// "Nicholas"</span>
    
<span class="c1">// 访问器属性名也可以是一个变量</span>
    
<span class="kd">let</span> <span class="nx">prototypeName</span> <span class="o">=</span> <span class="s2">"html"</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">CustonHTMLElement</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">element</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kd">get</span> <span class="p">[</span><span class="nx">prototypeName</span><span class="p">](){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">set</span> <span class="p">[</span><span class="nx">prototypeName</span><span class="p">](</span><span class="nx">value</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>生成器方法（将类方法定义成生成器）</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
      
  <span class="o">*</span><span class="nx">createIterator</span><span class="p">(){</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">createIterator</span><span class="p">();</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>类的默认生成器 Symbol.iterator</p>

        <blockquote>
          <p>如果用对象来表示集合，又希望通过简单的方法来迭代集合中的值，那么生成器方法就派上用场了。如果你想用类来表示值的集合，那么应该引入类的默认迭代器。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Collection</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="p">}</span>
        
  <span class="o">*</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">](){</span>
    <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
      
<span class="kd">var</span> <span class="nx">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Collection</span><span class="p">();</span>
<span class="nx">collection</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
      
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">collection</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
      
<span class="c1">// 输出：</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// 3</span>
</code></pre></div>        </div>
        <blockquote>
          <p>任何管理一系列值的类都应该引入默认迭代器，因为有一些与特定集合有关的操作需要所操作的集合含有一个迭代器。现在可以将Collection的实例直接用于 for-of 循环中或者用展开运算符操作它。</p>
        </blockquote>

        <blockquote>
          <p>如果不介意在对象的实例中出现添加的方法和访问器属性，则可以将它们添加到类的原型中；如果你希望它们只出现在类中，那么需要使用静态成员。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>类的静态成员</p>

    <blockquote>
      <p>在ES5及以前的版本中，一般会将方法直接添加到构造函数上来模拟静态成员。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">PersonType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="c1">// 静态方法</span>
  <span class="nx">PersonType</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">PersonType</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
    
  <span class="c1">// 实例方法</span>
  <span class="nx">PersonType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
    
  <span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="nx">PersonType</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="s2">"Nicholas"</span><span class="p">);</span> 
</code></pre></div>    </div>

    <blockquote>
      <p>在ES6中，类的语法简化了创建静态成员的过程，在方法或访问器属性名前使用正式的静态注释即可。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">PersonClass</span> <span class="p">{</span>
    <span class="c1">// 等价于 PersonType 构造函数</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="c1">//等价于PersonType.prototype.sayName</span>
    <span class="nx">sayName</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 等价于 PersonType.create</span>
    <span class="kr">static</span> <span class="nx">create</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
     <span class="k">return</span> <span class="k">new</span> <span class="nx">PersonClass</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <blockquote>
      <p>类中所有的方法和访问器属性都能使用关键字static来定义，唯一的限制是不能将static关键字用于定于构造函数方法。</p>
    </blockquote>

    <blockquote>
      <p>不可以在实例中访问静态成员，必须要直接在类中访问静态成员。</p>
    </blockquote>
  </li>
  <li>
    <p>继承与派生类</p>

    <blockquote>
      <p>在ES6之前，要实现继承与自定义类型是一个不小的工作，严格意义上的继承需要实现多个步骤。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
<span class="p">};</span>
    
<span class="kd">function</span> <span class="nx">Square</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
<span class="p">}</span>
    
<span class="nx">Square</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">constructor</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="nx">Square</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span>  <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
    
<span class="kd">var</span> <span class="nx">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Square</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true </span>
</code></pre></div>    </div>
    <blockquote>
      <p>类的出现让我们可以轻松实现继承功能，使用 extends 关键字可以指定类继承的函数。原型会自动调整，通过调用 super() 方法即可访问基类的构造函数。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="c1">// 等价于 Rectangle.call(this, length, length)</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Square</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>

    <blockquote>
      <p>继承自其它类的的类被称作派生类，如果在派生类中指定了构造函数则必须调用 super() ，如果不这样做程序会报错。如果选择不使用构造函数，则当创建新的类实例时会自动调用 super() 并传入所有参数。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
      
  <span class="c1">// 没有构造函数，其它一致</span>
    
<span class="p">}</span>
    
<span class="c1">// 等价于</span>
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(...</span><span class="nx">args</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>
        <p>使用 super() 时应该注意的几点：</p>

        <ul>
          <li>
            <p>只能在派生类的构造函数中使用super()，如果尝试在非派生类（不是使用extends声明的类）或函数中使用，会使程序报错。</p>
          </li>
          <li>
            <p>在构造函数中访问this之前一定要调用 super() ，它负责初始化this，如果在调用super() 之前尝试访问this会导致程序报错。</p>
          </li>
          <li>
            <p>如果不想调用super()，则唯一的方法是让类的构造函数返回一个对象。</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>类方法遮蔽</p>

    <blockquote>
      <p>派生类中的方法中会覆盖基类中的同名方法，如果你想调用基类中的该方法，可以通过super来单独调用，请看下面的代码：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="c1">// 覆盖并遮蔽 Rectangle.prototype.getArea() 方法</span>
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="c1">// 调用基类中的 getArea() 方法</span>
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="c1">// 覆盖遮蔽后调用 Rectangle.prototype.getArea() 方法</span>
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">super</span><span class="p">.</span><span class="nx">getArea</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>    
</code></pre></div>    </div>
  </li>
  <li>
    <p>静态成员继承</p>

    <blockquote>
      <p>如果基类中有静态成员，那么这些静态成员在派生类中也可以使用。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kr">static</span> <span class="nx">create</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">);</span>
  <span class="p">}</span>    
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="c1">// 等价于 Rectangle.call(this, length, length)</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">Square</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rect</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 12</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rect</span> <span class="k">instanceof</span> <span class="nx">Square</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rect</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>派生至表达式的类</p>

    <blockquote>
      <p>ES6最强大的一面或许是从表达式导出类的功能了。只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以利用extends进行派生。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
<span class="p">};</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>   
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true    </span>
</code></pre></div>    </div>
    <blockquote>
      <p>Rectangle是一个ES5风格的构造函数，Square是一个类，由于Rectangle具有[[Construct]]属性和原型，因此Square类可以直接继承它。</p>
    </blockquote>

    <blockquote>
      <p>extends 强大的功能使得类可以继承自任意类型的表达式，从而可以创造出更多的可能性，例如动态地确定类的继承目标，如下：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
<span class="p">};</span>
    
<span class="kd">function</span> <span class="nx">getBase</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Rectangle</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">getBase</span><span class="p">(){</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>   
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <blockquote>
      <p>getBase()函数是类声明的一部分，直接调用后返回Rectangle，由于可以动态确定使用哪个基类，因此可以创建不同的继承方法。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">SerializableMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">serialize</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
    
<span class="kd">let</span> <span class="nx">AreaMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
    
<span class="kd">function</span> <span class="nx">mixin</span><span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">base</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>    
  <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">base</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">...</span><span class="nx">mixins</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">base</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">mixin</span><span class="p">(</span><span class="nx">AreaMixin</span><span class="p">,</span> <span class="nx">SerializableMixin</span><span class="p">){</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    
    <span class="c1">// 由于使用了 extends 所以这里必须使用 super()</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">serialize</span><span class="p">());</span> <span class="c1">// "{"length":3, "width": 3}"</span>
</code></pre></div>    </div>
    <blockquote>
      <p>如果多个mixin对象具有相同的属性，那么只有最后一个被添加的属性会被保留。在extends后可以使用任意表达式，但不是所有表达式最终都能生成合法的类。如果使用null或者生成器函数就会导致程序报错，因为null和生成器函数没有[[Construct]]属性，尝试为其创建新的实例会导致程序无法调用[[Construct]]而报错。</p>
    </blockquote>
  </li>
  <li>
    <p>内建对象的继承</p>

    <blockquote>
      <p>自JavaScript 数组诞生以来，开发者一直希望通过继承的方式创建属于自己的特殊数组。在ES5以及早期版本中，这几乎是不可能的，用传统的继承方式无法实现这样的功能。请看下面的代码：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
<span class="c1">// 内建数组行为</span>
<span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">//1</span>
    
<span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// undefined</span>
    
<span class="c1">// 尝试使用ES5语法继承数组</span>
<span class="kd">function</span> <span class="nx">MyArray</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">Array</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>
    
<span class="nx">MyArray</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">constructor</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="nx">MyArray</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
    
<span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">();</span>
<span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>  <span class="c1">// 0</span>
    
<span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="c1">// "red"</span>
</code></pre></div>    </div>

    <blockquote>
      <p>这段代码最后的console.log()输出的内容与预期不符，MyArray实例的length和数值型属性的行为与内建数组中的不一致，这是因为通过传统JS集成形式实现的数组继承没有从Array.apply()或原型赋值中继承相关功能。</p>
    </blockquote>

    <blockquote>
      <p>ES6中类语法的一个目标就是支持内建对象的继承，它和ES5及早期版本的继承有所不同，主要是如下两点：</p>
    </blockquote>

    <ul>
      <li>
        <p>ES5中的传统继承，先由派生类型创建this的值，然后调用基类的构造函数，这也就意味着，this的值开始指向的是MyArray的实例，但是后面被来自Array的其他属性所修饰。</p>
      </li>
      <li>
        <p>ES6中的类继承则与之相反，先由基类创建this的值，然后派生类的构造函数再来修改这个值，所以一开始可以通过this访问基类的所有内建功能，然后再正确地接收所有与之相关的功能。</p>
      </li>
    </ul>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyArray</span> <span class="kd">extends</span> <span class="nb">Array</span><span class="p">{</span>
  <span class="c1">// 空</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">();</span>
<span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>  <span class="c1">// 1</span>
    
<span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="c1">// "red"    </span>
</code></pre></div>    </div>
    <blockquote>
      <p>MyArray 直接继承自Array，其行为和Array也很相似。当然也可以继承其他的内建对象。</p>
    </blockquote>
  </li>
  <li>
    <p>Symbol.species 属性</p>

    <blockquote>
      <p>内建对象继承的一个实用之处是，原本在内建对象中返回的实例自身的方法将自动返回派生类的实例。所以，如果你有一个继承自Array的派生类MyArray，那么像slice()这样的方法也会返回一个MyArray的实例。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyArray</span> <span class="kd">extends</span> <span class="nb">Array</span><span class="p">{</span>
  <span class="c1">// 空</span>
<span class="p">}</span>
    
<span class="kd">let</span> <span class="nx">items</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">subItems</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">items</span> <span class="k">instanceof</span> <span class="nx">MyArray</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subItems</span> <span class="k">instanceof</span> <span class="nx">MyArray</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <blockquote>
      <p>正常情况下，继承自Array的 slice() 方法应该返回 Array 的实例，但是在这段代码中返回的是 MyArray 的实例。这是浏览器在背后通过 symbol.species 属性实现这一行为的。</p>
    </blockquote>

    <blockquote>
      <p>Symbol.species 是诸多内部Symbol中的一个，它被用于定义返回函数的静态访问器属性。被返回的函数是一个构造函数，每当要在实例的方法中创建类的实例时必须使用这个构造函数。以下这些内建类型均已定义Symbol.species属性：</p>
    </blockquote>

    <ul>
      <li>
        <p>Array</p>
      </li>
      <li>
        <p>ArrayBuffer</p>
      </li>
      <li>
        <p>Map</p>
      </li>
      <li>
        <p>Promise</p>
      </li>
      <li>
        <p>RegExp</p>
      </li>
      <li>
        <p>Set</p>
      </li>
      <li>
        <p>Typed arrays</p>
      </li>
    </ul>

    <blockquote>
      <p>列表中的每个类型都有一个默认的Symbol.species属性，该属性的返回值为this，这也意味着该属性总是返回构造函数。如果在自定义的类中实现这个功能，则代码看起来可能是这样的：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Symbol.species 这一节比较偏，暂时搁置</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在类的构造函数中使用 new.target</p>

    <blockquote>
      <p>在类的构造函数中可以通过 new.target 来确定类是如何被调用的，在简单情况下，new.target 等于类的构造函数。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="c1">// new.target 的值是  Rectangle    </span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 输出 true</span>
</code></pre></div>    </div>

    <blockquote>
      <p>类构造函数必须通过关键字new调用，所以总是在类的构造函数中定义new.target属性。但是其值有时候会不同。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span> 
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>   
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span> 
<span class="c1">// new.target 的值是  Rectangle    </span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 输出 false     </span>
</code></pre></div>    </div>
    <blockquote>
      <p>Square 调用 Rectangle 的构造函数，所以当调用发生时， new.target 等于Square。这一点非常重要，因为每个构造函数都可以根据自身被调用的方式改变自己的行为。比如，可以用 new.target 创建一个抽象类（不能被直接实例化的类）：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Shape</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Shape</span><span class="p">){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'这个类不能被直接实例化'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Rectangle</span> <span class="kd">extends</span> <span class="nx">Shape</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Shape</span><span class="p">();</span> <span class="c1">// 抛出错误</span>
    
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 没有错误</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span> <span class="k">instanceof</span> <span class="nx">Shape</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <blockquote>
      <p>虽然 new Shape() 时总是报错，但是仍然可以用 Shape 作为基类派生其他类。super() 调用执行了 Shape 的构造函数，new.target 与 Rectangle 等价，所以构造函数继续执行不会抛出错误。</p>
    </blockquote>

    <blockquote>
      <p>因为类必须通过关键字 new 才能调用，所以在类的构造函数中，new.target 属性永远不会是undefind。</p>
    </blockquote>
  </li>
</ul>

<h3>2. Promise 与异步编程</h3>

<h3>3. 代理（Proxy）</h3>

</div>
    </div>
    <div class="sidebar-list">
        <div class="tag-cloud">
    <ul>
        <li>JavaScript</li>
        <li>Node.js</li>
        <li>Vue</li>
        <li>React</li>
        <li>Koa2</li>
        <li>Webpack</li>
        <li>TypeScript</li>
        <li>Express</li>
    </ul>
</div>
        <div class="search-box">
    <div class="search-holder">
        <input class="search-input" type="text" placeholder="没事别瞎点搜索">
    </div>
</div>
        <div class="blog-author">
    <div class="avatar">
        <img src="/assets/images/avatar/dfyc.jpeg" alt="" width="160">
    </div>
    <ul>
        <li>昵称：lizm</li>
        <li>性别：少年</li>
        <li>生日：1993-03-29</li>
        <li>签名：</li>
        <li>hahaahahhahahahahahaahahhahahaahah</li>
    </ul>
</div>
        <div class="date-picker">
    <link rel="stylesheet" href="/lib/calendar/css/calendar.css">
    <script src="/lib/jquery/jquery-3.4.1.js"></script>
    <script src="/lib/calendar/js/calendar.js"></script>
    <div id="calendar" class="calendar"></div>
</div>
        <div class="hot-posts">

</div>
    </div>
</div>
</body>
</html>