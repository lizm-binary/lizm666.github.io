<!DOCTYPE html>
<html lang="zh">
<!--[if IE 8]>
<html class="no-js lt-ie9" lang="zh">
<![endif]-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta http-equiv="Pragma" content="no-cache" />
    <meta name="description" content="">
    <meta name="keywords" content="">
    <title>深入理解ES6（三）</title>
    <link rel="stylesheet" href="/lib/animate.css/animate.css">
    <link rel="stylesheet" href="/assets/css/md-wrap.css">
    <link rel="stylesheet" href="/assets/css/styles.css">
</head>
<body>

<div class="nav">
	<div style="display: inline-block;float: left;margin-left: 80px;height: 80px;line-height: 80px;color: #fff;font-size: 22px;">
		广告位招租
	</div>
    <ul>
        
        <li><a href="/" >Home</a></li>
        
        <li><a href="/about.html" >About</a></li>
        
    </ul>
</div>
<!DOCTYPE html>
<html lang="zh">
<!--[if IE 8]>
<html class="no-js lt-ie9" lang="zh">
<![endif]-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta http-equiv="Pragma" content="no-cache" />
    <meta name="description" content="">
    <meta name="keywords" content="">
    <title>Title</title>
    <link rel="stylesheet" href="">
</head>
<body>


<script src=""></script>
</body>

<div class="container">
    <div class="post bounceInUp animated">
        <div class="header">
            <div class="title">深入理解ES6（三）</div>
            <div class="info">
                <span class="view-count">192</span>
                <span class="dot">·</span>
                <span class="date">2019-09-30</span>
                <span class="dot">·</span>
                <span class="author">lizm</span>
            </div>
        </div>
        
<div class="music-box">
    <div class="music-name-author">
        ♬：<span>岁月神偷-金玟岐</span>
    </div>
    <video controls="" autoplay="" name="media" loop="">
        <source src="http://127.0.0.1:4000/assets/music/suiyueshentou.m4a" type="audio/mp4">
    </video>
</div>

        <div class="content post-content"><p>ES6的注意点和一些使用技巧总结，第三篇包括JavaScript 中的类（Class），Promise 与异步编程，代理（Proxy）。</p>

<h3>1. JavaScript 中的类（Class）</h3>

<ul>
  <li>
    <p>ES5中的近类结构</p>

    <blockquote>
      <p>在ES5以及早期版本中没有类的概念，最相近的思路是创建一个自定义类型：首先创建一个构造函数，然后定义一个方法并赋值给构造函数的原型。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">PersonType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">PersonType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PersonType</span><span class="p">(</span><span class="s1">'Nicholas'</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">// "Nicholas"</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span> <span class="k">instanceof</span> <span class="nx">PersonType</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>

    <blockquote>
      <p>许多模拟类的JS库都是基于这个模式开发的，ES6也是借鉴了类似的方法。</p>
    </blockquote>
  </li>
  <li>
    <p>类的声明</p>

    <blockquote>
      <p>使用关键字 class 后面紧跟类的名字，然后加上花括号{}，{}内是类的具体实现，其语法类似于对象字面量方法，只是各元素之间不再需要使用逗号分隔。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">PersonClass</span> <span class="p">{</span>
      
  <span class="c1">// 相当于ES5中 PersonType 的构造函数</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="c1">// 相当于ES5中 PersonType.prototype.sayName</span>
  <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <blockquote>
      <p>私有属性是实例中的属性，不会出现在原型上，且只有在类的构造函数或者方法中创建，上面的name就是一个私有属性。一般建议在构造函数里面创建好所有的私有属性，方便只在一个地方统一管理所有的私有属性。</p>
    </blockquote>

    <blockquote>
      <p>事实上，类的声明只是基于已有自定义类型声明的语法糖。但是与函数不同的是，类属性不可以被赋予新的值。</p>
    </blockquote>
  </li>
  <li>
    <p>为什么要使用类语法</p>

    <blockquote>
      <p>尽管类声明和自定义类型之间有很多相似的地方，但我们仍然需要记住下面这些区别：</p>
    </blockquote>

    <ul>
      <li>
        <p>函数声明可以被提升，但是类声明不能被提升，真正执行声明语句之前，它们会一直处在临时死区内。</p>
      </li>
      <li>
        <p>类声明中的说有代码都将自动在严格模式下执行，且无法强制让代码脱离严格模式。</p>
      </li>
      <li>
        <p>在类中所有的方法都是不可枚举的，但是在自定义类型中，可以通过Object.defineProperty()方法手工设置某个方法是否可枚举。</p>
      </li>
      <li>
        <p>每个类都有一个名为[[Construct]]的内部方法，通过关键字new调用那些不含[[Construct]]的方法时，程序将抛出错误。</p>
      </li>
      <li>
        <p>使用出关键字new之外的方式调用类的构造函数，会导致程序报错。</p>
      </li>
      <li>
        <p>在类中修改类名，程序会报错。</p>
      </li>
    </ul>

    <blockquote>
      <p>虽然不能在类的方法中修改类名，但是可以在外部修改。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(){</span>
      <span class="nx">Foo</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span> <span class="c1">// 程序报错</span>
    <span class="p">}</span>
  <span class="p">}</span>
    
  <span class="nx">Foo</span> <span class="o">=</span> <span class="s1">'biz'</span><span class="p">;</span> <span class="c1">// 可以修改</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>类表达式</p>

    <blockquote>
      <p>除了可以声明一个类，还可以使用表达式来创建，就像创建一个函数一样。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">PersonClass</span> <span class="o">=</span> <span class="kd">class</span><span class="p">{</span>
  <span class="c1">// 内部实现一致</span>
<span class="p">}</span>
    
</code></pre></div>    </div>
    <blockquote>
      <p>也可以创建一个具名类。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">PersonClass</span> <span class="o">=</span> <span class="kd">class</span> <span class="nx">PersonClass2</span> <span class="p">{</span>
  <span class="c1">//内部实现一致</span>
<span class="p">};</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">PersonClass2</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div>    </div>

    <blockquote>
      <p>类表达式同样不会被提升，匿名类表达式的name属性是一个空字符串，但是类声明的name属性值是类名。具名类表达式中，类的名称只能在类的内部使用。</p>
    </blockquote>
  </li>
  <li>
    <p>作为一等公民的类</p>

    <blockquote>
      <p>在程序中，一等公民是指一个可以传入函数，可以从函数返回，并且可以赋值给变量的值。JS函数就是一等公民，类也是一等公民。ES6中依然保持了类的一等公民身份，允许通过多种方式使用类的特性。</p>
    </blockquote>

    <ul>
      <li>
        <p>类作为参数传入函数中</p>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createObject</span><span class="p">(</span><span class="nx">classDef</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">classDef</span><span class="p">();</span>
<span class="p">}</span>
        
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">createObject</span><span class="p">(</span><span class="kd">class</span> <span class="p">{</span>

  <span class="nx">sayHi</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Hi!'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
        
<span class="nx">obj</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span>  <span class="c1">// 'Hi!'</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>通过立即调用类的构造函数来创建单例</p>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="kd">class</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">sayName</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}(</span><span class="s1">'Nicholas'</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//'Nicholas' </span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>访问器属性</p>

    <blockquote>
      <p>尽管应该在类构造函数中创建自己的属性，但是类也支持直接在原型上定义访问器属性（getter 和 setter）。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">CustomHTMLElement</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">el</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">el</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kd">get</span> <span class="nx">html</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kd">set</span> <span class="nx">html</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">CustomHTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">'html'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"get"</span> <span class="k">in</span>  <span class="nx">descriptor</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"set"</span> <span class="k">in</span>  <span class="nx">descriptor</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span><span class="p">);</span> <span class="c1">// false</span>
</code></pre></div>    </div>

    <blockquote>
      <p>使用非类形式实现会比使用类实现要复杂些</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">CustomHTMLElement</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="s2">"use strict"</span><span class="p">;</span>
      
  <span class="kd">const</span> <span class="nx">CustomHTMLElement</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="s2">"undefined"</span><span class="p">){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"必须通过关键字new调用构造函数"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">CustomHTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span><span class="s2">"html"</span><span class="p">,{</span>
    <span class="na">enumerable</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">get</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHtml</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="na">set</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHtml</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
    
  <span class="k">return</span> <span class="nx">CustomHTMLElement</span><span class="p">;</span>
<span class="p">}());</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>可计算成员名称（属性名或者方法名是一个变量）</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 方法名是一个变量</span>
    
<span class="kd">let</span> <span class="nx">methodName</span> <span class="o">=</span> <span class="s1">'sayName'</span><span class="p">;</span>
    
<span class="kd">class</span> <span class="nx">PersonClass</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">[</span><span class="nx">methodName</span><span class="p">](){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PersonClass</span><span class="p">(</span><span class="s1">'Nicholas'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="nx">sayName</span><span class="p">());</span> <span class="c1">// "Nicholas"</span>
    
<span class="c1">// 访问器属性名也可以是一个变量</span>
    
<span class="kd">let</span> <span class="nx">prototypeName</span> <span class="o">=</span> <span class="s2">"html"</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">CustonHTMLElement</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">element</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kd">get</span> <span class="p">[</span><span class="nx">prototypeName</span><span class="p">](){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">set</span> <span class="p">[</span><span class="nx">prototypeName</span><span class="p">](</span><span class="nx">value</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>生成器方法（将类方法定义成生成器）</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
      
  <span class="o">*</span><span class="nx">createIterator</span><span class="p">(){</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">createIterator</span><span class="p">();</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>类的默认生成器 Symbol.iterator</p>

        <blockquote>
          <p>如果用对象来表示集合，又希望通过简单的方法来迭代集合中的值，那么生成器方法就派上用场了。如果你想用类来表示值的集合，那么应该引入类的默认迭代器。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Collection</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="p">}</span>
        
  <span class="o">*</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">](){</span>
    <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">values</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
      
<span class="kd">var</span> <span class="nx">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Collection</span><span class="p">();</span>
<span class="nx">collection</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
      
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">collection</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
      
<span class="c1">// 输出：</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
<span class="c1">// 3</span>
</code></pre></div>        </div>
        <blockquote>
          <p>任何管理一系列值的类都应该引入默认迭代器，因为有一些与特定集合有关的操作需要所操作的集合含有一个迭代器。现在可以将Collection的实例直接用于 for-of 循环中或者用展开运算符操作它。</p>
        </blockquote>

        <blockquote>
          <p>如果不介意在对象的实例中出现添加的方法和访问器属性，则可以将它们添加到类的原型中；如果你希望它们只出现在类中，那么需要使用静态成员。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>类的静态成员</p>

    <blockquote>
      <p>在ES5及以前的版本中，一般会将方法直接添加到构造函数上来模拟静态成员。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">PersonType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="c1">// 静态方法</span>
  <span class="nx">PersonType</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">PersonType</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
    
  <span class="c1">// 实例方法</span>
  <span class="nx">PersonType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
    
  <span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="nx">PersonType</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="s2">"Nicholas"</span><span class="p">);</span> 
</code></pre></div>    </div>

    <blockquote>
      <p>在ES6中，类的语法简化了创建静态成员的过程，在方法或访问器属性名前使用正式的静态注释即可。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">PersonClass</span> <span class="p">{</span>
    <span class="c1">// 等价于 PersonType 构造函数</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="c1">//等价于PersonType.prototype.sayName</span>
    <span class="nx">sayName</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 等价于 PersonType.create</span>
    <span class="kr">static</span> <span class="nx">create</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
     <span class="k">return</span> <span class="k">new</span> <span class="nx">PersonClass</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <blockquote>
      <p>类中所有的方法和访问器属性都能使用关键字static来定义，唯一的限制是不能将static关键字用于定于构造函数方法。</p>
    </blockquote>

    <blockquote>
      <p>不可以在实例中访问静态成员，必须要直接在类中访问静态成员。</p>
    </blockquote>
  </li>
  <li>
    <p>继承与派生类</p>

    <blockquote>
      <p>在ES6之前，要实现继承与自定义类型是一个不小的工作，严格意义上的继承需要实现多个步骤。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
<span class="p">};</span>
    
<span class="kd">function</span> <span class="nx">Square</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Rectangle</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
<span class="p">}</span>
    
<span class="nx">Square</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">constructor</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="nx">Square</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span>  <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
    
<span class="kd">var</span> <span class="nx">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Square</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true </span>
</code></pre></div>    </div>
    <blockquote>
      <p>类的出现让我们可以轻松实现继承功能，使用 extends 关键字可以指定类继承的函数。原型会自动调整，通过调用 super() 方法即可访问基类的构造函数。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="c1">// 等价于 Rectangle.call(this, length, length)</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Square</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>

    <blockquote>
      <p>继承自其它类的的类被称作派生类，如果在派生类中指定了构造函数则必须调用 super() ，如果不这样做程序会报错。如果选择不使用构造函数，则当创建新的类实例时会自动调用 super() 并传入所有参数。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
      
  <span class="c1">// 没有构造函数，其它一致</span>
    
<span class="p">}</span>
    
<span class="c1">// 等价于</span>
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(...</span><span class="nx">args</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>
        <p>使用 super() 时应该注意的几点：</p>

        <ul>
          <li>
            <p>只能在派生类的构造函数中使用super()，如果尝试在非派生类（不是使用extends声明的类）或函数中使用，会使程序报错。</p>
          </li>
          <li>
            <p>在构造函数中访问this之前一定要调用 super() ，它负责初始化this，如果在调用super() 之前尝试访问this会导致程序报错。</p>
          </li>
          <li>
            <p>如果不想调用super()，则唯一的方法是让类的构造函数返回一个对象。</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>类方法遮蔽</p>

    <blockquote>
      <p>派生类中的方法中会覆盖基类中的同名方法，如果你想调用基类中的该方法，可以通过super来单独调用，请看下面的代码：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="c1">// 覆盖并遮蔽 Rectangle.prototype.getArea() 方法</span>
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="c1">// 调用基类中的 getArea() 方法</span>
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="c1">// 覆盖遮蔽后调用 Rectangle.prototype.getArea() 方法</span>
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">super</span><span class="p">.</span><span class="nx">getArea</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>    
</code></pre></div>    </div>
  </li>
  <li>
    <p>静态成员继承</p>

    <blockquote>
      <p>如果基类中有静态成员，那么这些静态成员在派生类中也可以使用。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="kr">static</span> <span class="nx">create</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">);</span>
  <span class="p">}</span>    
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    <span class="c1">// 等价于 Rectangle.call(this, length, length)</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="nx">Square</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rect</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 12</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rect</span> <span class="k">instanceof</span> <span class="nx">Square</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rect</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>派生至表达式的类</p>

    <blockquote>
      <p>ES6最强大的一面或许是从表达式导出类的功能了。只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以利用extends进行派生。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
<span class="p">};</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>   
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true    </span>
</code></pre></div>    </div>
    <blockquote>
      <p>Rectangle是一个ES5风格的构造函数，Square是一个类，由于Rectangle具有[[Construct]]属性和原型，因此Square类可以直接继承它。</p>
    </blockquote>

    <blockquote>
      <p>extends 强大的功能使得类可以继承自任意类型的表达式，从而可以创造出更多的可能性，例如动态地确定类的继承目标，如下：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="nx">Rectangle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
<span class="p">};</span>
    
<span class="kd">function</span> <span class="nx">getBase</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Rectangle</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">getBase</span><span class="p">(){</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>   
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">Rectangle</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <blockquote>
      <p>getBase()函数是类声明的一部分，直接调用后返回Rectangle，由于可以动态确定使用哪个基类，因此可以创建不同的继承方法。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">SerializableMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">serialize</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
    
<span class="kd">let</span> <span class="nx">AreaMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">getArea</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
    
<span class="kd">function</span> <span class="nx">mixin</span><span class="p">(...</span><span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">base</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>    
  <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">base</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">...</span><span class="nx">mixins</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">base</span><span class="p">;</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">mixin</span><span class="p">(</span><span class="nx">AreaMixin</span><span class="p">,</span> <span class="nx">SerializableMixin</span><span class="p">){</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>
    
    <span class="c1">// 由于使用了 extends 所以这里必须使用 super()</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">getArea</span><span class="p">());</span> <span class="c1">// 9</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">serialize</span><span class="p">());</span> <span class="c1">// "{"length":3, "width": 3}"</span>
</code></pre></div>    </div>
    <blockquote>
      <p>如果多个mixin对象具有相同的属性，那么只有最后一个被添加的属性会被保留。在extends后可以使用任意表达式，但不是所有表达式最终都能生成合法的类。如果使用null或者生成器函数就会导致程序报错，因为null和生成器函数没有[[Construct]]属性，尝试为其创建新的实例会导致程序无法调用[[Construct]]而报错。</p>
    </blockquote>
  </li>
  <li>
    <p>内建对象的继承</p>

    <blockquote>
      <p>自JavaScript 数组诞生以来，开发者一直希望通过继承的方式创建属于自己的特殊数组。在ES5以及早期版本中，这几乎是不可能的，用传统的继承方式无法实现这样的功能。请看下面的代码：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
<span class="c1">// 内建数组行为</span>
<span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">//1</span>
    
<span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// undefined</span>
    
<span class="c1">// 尝试使用ES5语法继承数组</span>
<span class="kd">function</span> <span class="nx">MyArray</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">Array</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>
<span class="p">}</span>
    
<span class="nx">MyArray</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">constructor</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">value</span><span class="p">:</span> <span class="nx">MyArray</span><span class="p">,</span>
    <span class="na">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">});</span>
    
<span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">();</span>
<span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>  <span class="c1">// 0</span>
    
<span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="c1">// "red"</span>
</code></pre></div>    </div>

    <blockquote>
      <p>这段代码最后的console.log()输出的内容与预期不符，MyArray实例的length和数值型属性的行为与内建数组中的不一致，这是因为通过传统JS集成形式实现的数组继承没有从Array.apply()或原型赋值中继承相关功能。</p>
    </blockquote>

    <blockquote>
      <p>ES6中类语法的一个目标就是支持内建对象的继承，它和ES5及早期版本的继承有所不同，主要是如下两点：</p>
    </blockquote>

    <ul>
      <li>
        <p>ES5中的传统继承，先由派生类型创建this的值，然后调用基类的构造函数，这也就意味着，this的值开始指向的是MyArray的实例，但是后面被来自Array的其他属性所修饰。</p>
      </li>
      <li>
        <p>ES6中的类继承则与之相反，先由基类创建this的值，然后派生类的构造函数再来修改这个值，所以一开始可以通过this访问基类的所有内建功能，然后再正确地接收所有与之相关的功能。</p>
      </li>
    </ul>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyArray</span> <span class="kd">extends</span> <span class="nb">Array</span><span class="p">{</span>
  <span class="c1">// 空</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">();</span>
<span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>  <span class="c1">// 1</span>
    
<span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="c1">// "red"    </span>
</code></pre></div>    </div>
    <blockquote>
      <p>MyArray 直接继承自Array，其行为和Array也很相似。当然也可以继承其他的内建对象。</p>
    </blockquote>
  </li>
  <li>
    <p>Symbol.species 属性</p>

    <blockquote>
      <p>内建对象继承的一个实用之处是，原本在内建对象中返回的实例自身的方法将自动返回派生类的实例。所以，如果你有一个继承自Array的派生类MyArray，那么像slice()这样的方法也会返回一个MyArray的实例。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyArray</span> <span class="kd">extends</span> <span class="nb">Array</span><span class="p">{</span>
  <span class="c1">// 空</span>
<span class="p">}</span>
    
<span class="kd">let</span> <span class="nx">items</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">subItems</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">items</span> <span class="k">instanceof</span> <span class="nx">MyArray</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subItems</span> <span class="k">instanceof</span> <span class="nx">MyArray</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <blockquote>
      <p>正常情况下，继承自Array的 slice() 方法应该返回 Array 的实例，但是在这段代码中返回的是 MyArray 的实例。这是浏览器在背后通过 symbol.species 属性实现这一行为的。</p>
    </blockquote>

    <blockquote>
      <p>Symbol.species 是诸多内部Symbol中的一个，它被用于定义返回函数的静态访问器属性。被返回的函数是一个构造函数，每当要在实例的方法中创建类的实例时必须使用这个构造函数。以下这些内建类型均已定义Symbol.species属性：</p>
    </blockquote>

    <ul>
      <li>
        <p>Array</p>
      </li>
      <li>
        <p>ArrayBuffer</p>
      </li>
      <li>
        <p>Map</p>
      </li>
      <li>
        <p>Promise</p>
      </li>
      <li>
        <p>RegExp</p>
      </li>
      <li>
        <p>Set</p>
      </li>
      <li>
        <p>Typed arrays</p>
      </li>
    </ul>

    <blockquote>
      <p>列表中的每个类型都有一个默认的Symbol.species属性，该属性的返回值为this，这也意味着该属性总是返回构造函数。如果在自定义的类中实现这个功能，则代码看起来可能是这样的：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Symbol.species 这一节比较偏，暂时搁置</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在类的构造函数中使用 new.target</p>

    <blockquote>
      <p>在类的构造函数中可以通过 new.target 来确定类是如何被调用的，在简单情况下，new.target 等于类的构造函数。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="c1">// new.target 的值是  Rectangle    </span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 输出 true</span>
</code></pre></div>    </div>

    <blockquote>
      <p>类构造函数必须通过关键字new调用，所以总是在类的构造函数中定义new.target属性。但是其值有时候会不同。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Rectangle</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span> 
    
<span class="kd">class</span> <span class="nx">Square</span> <span class="kd">extends</span> <span class="nx">Rectangle</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">){</span>   
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span> 
<span class="c1">// new.target 的值是  Rectangle    </span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 输出 false     </span>
</code></pre></div>    </div>
    <blockquote>
      <p>Square 调用 Rectangle 的构造函数，所以当调用发生时， new.target 等于Square。这一点非常重要，因为每个构造函数都可以根据自身被调用的方式改变自己的行为。比如，可以用 new.target 创建一个抽象类（不能被直接实例化的类）：</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Shape</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">Shape</span><span class="p">){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'这个类不能被直接实例化'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">class</span> <span class="nx">Rectangle</span> <span class="kd">extends</span> <span class="nx">Shape</span><span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">){</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Shape</span><span class="p">();</span> <span class="c1">// 抛出错误</span>
    
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 没有错误</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span> <span class="k">instanceof</span> <span class="nx">Shape</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <blockquote>
      <p>虽然 new Shape() 时总是报错，但是仍然可以用 Shape 作为基类派生其他类。super() 调用执行了 Shape 的构造函数，new.target 与 Rectangle 等价，所以构造函数继续执行不会抛出错误。</p>
    </blockquote>

    <blockquote>
      <p>因为类必须通过关键字 new 才能调用，所以在类的构造函数中，new.target 属性永远不会是undefind。</p>
    </blockquote>
  </li>
</ul>

<h3>2. Promise 与异步编程</h3>

<ul>
  <li>
    <p>异步编程的背景</p>

    <blockquote>
      <p>JavaScript 引擎是基于单线程事件循环的概念构建的，同一时刻只允许一个代码块在执行，所以需要跟踪即将运行的代码，那些代码被放在一个任务队列中，每当一段代码准备执行时，都会被添加到任务队列。每当JS引擎中的一段代码执行结束，事件循环会执行队列中的下一个任务，它是JS引擎中的一段程序，负责监控代码执行并管理任务队列。请记住，队列中的任务会从第一个一直执行到最后一个。</p>
    </blockquote>

    <ul>
      <li>
        <p>事件模型</p>

        <blockquote>
          <p>用户点击按钮或者按下键盘上的按键会触发类似 onclick 这样的事件，它会向任务队列添加一个新任务来响应用户的操作，这是 JS 中最基础的异步编程形式，直到事件触发时才执行事件处理程序，且执行时上下文与定义时的相同。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'my-btn'</span><span class="p">);</span>
<span class="nx">button</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Clicked'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
        <blockquote>
          <p>事件模型适用于简单的交互处理，然而将多个独立的异步调用连接在一起会使程序更加复杂，因为你必须跟踪每个事件的事件目标。从外，必须要保证事件在添加时间处理程序之后才被触发。所以，尽管事件模型适用于响应用户交互和完成类似的低频功能，但其对于更复杂的需求来说却不是很灵活。</p>
        </blockquote>
      </li>
      <li>
        <p>回调模式</p>

        <blockquote>
          <p>Node.js 通过普及回调函数来改进异步编程模型，回调模式与事件模型类似，异步代码都会在将来的某个时间点执行，二者的区别是回调模式中被调用的函数是作为参数传入的。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">readFile</span><span class="p">(</span><span class="s2">"example.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
    <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
<span class="p">});</span>
      
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hi"</span><span class="p">);</span>
</code></pre></div>        </div>
        <blockquote>
          <p>Node.js 推行错误优先的回调风格。回调模式比事件模型更灵活，因为相比之下，回调模式链接多个调用更容易。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">readFile</span><span class="p">(</span><span class="s2">"example.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
    <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
  <span class="p">}</span>
      
  <span class="nx">writeFile</span><span class="p">(</span><span class="s2">"example.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
      <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
    <span class="p">}</span>
       
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"File was written"</span><span class="p">);</span>
  <span class="p">});</span>       
<span class="p">});</span>      
</code></pre></div>        </div>
        <blockquote>
          <p>虽然这个模式运行效果很不错，但是很快你就会发现，由于嵌套太多层回调函数会导致代码陷入回调地狱而变得难以理解和维护。如果你想实现更复杂的功能，比如并行执行两个异步操作，当两个操作都结束时通知你；或者同时进行两个异步操作，只取优先完成的操作结果。这种情况你需要跟踪多个回调函数并清理这些操作，Promise就能很好地改善这样的情况。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>Promise 的基础知识</p>

    <blockquote>
      <p>Promise相当于异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标函数，而是让函数返回一个Promise对象。未来对这个对象的操作完全取决于Promise的生命周期。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">readFile</span><span class="p">(</span><span class="s2">"example.txt"</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>Promise 的生命周期</p>

        <blockquote>
          <p>每个Promise 都会经历一个短暂的生命周期：先是处于进行中（pending）的状态，此时操作尚未完成，所以它也是未处理（unsettled）的；一旦异步操作执行结束，Promise则变成已处理（settled）的状态。已处理的状态包含两种：</p>
        </blockquote>

        <ul>
          <li>
            <p>Fulfilled， Promise 异步操作成功完成。</p>
          </li>
          <li>
            <p>Rejected， 由于程序错误或者一些其他原因，Promise异步操作未能成功完成。</p>
          </li>
        </ul>

        <blockquote>
          <p>内部属性[[PromiseState]]被用来表示Promise的3种状态：“pending”、“fulfilled”、“rejected”。这个属性不会暴露在Promise对象上，所以不能以编程的方式检测到Promise的状态，只有当Promise的状态改变时，通过then()方法采取特定的行动。</p>
        </blockquote>

        <blockquote>
          <p>所有的Promise都有then() 方法，它接受两个参数：第一个是当Promise的状态变为 fulfilled 时要调用的函数，与异步操作相关的附加数据都会传递给这个完成函数（fulfillment function）；第二个是当Promise的状态改变为 rejected 时要调用的函数，其与完成时调用的函数类似，所有与失败状态相关的附加数据都会传递给这个拒绝函数（rejection function）。</p>
        </blockquote>

        <blockquote>
          <p>如果一个对象实现了上述的then() 方法，那这个对象我们称之为 thenable 对象。所有的Promise对象都是thenable对象，但不是所以的thenable对象都是Promise对象。</p>
        </blockquote>

        <blockquote>
          <p>then() 方法的两个参数都是可选的，可以按照需要任意组合来监听Promise，示例代码如下：</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">readFile</span><span class="p">(</span><span class="s2">"example.txt"</span><span class="p">);</span>
      
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 完成</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 拒绝</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>
      
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 完成</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
<span class="p">});</span>
      
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 拒绝</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>        </div>
        <blockquote>
          <p>Promise 还有一个 catch() 方法，相当于只给其传入拒绝处理程序的 then() 方法。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 拒绝</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>
      
<span class="c1">// 与以下调用相同</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 拒绝</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>      
</code></pre></div>        </div>

        <blockquote>
          <p>then() 方法和 catch() 方法配合起来使用才能更好地处理异步操作的结果。这套体系能清楚地指明异步操作结果是成功还是失败，比起事件模型和回调函数更好用。但是要记住，如果不给 Promise 添加拒绝处理程序，那所有的失败就自动被忽略了，所以一定要添加拒绝处理程序，即使只在函数内部记录失败的结果也行。</p>
        </blockquote>

        <blockquote>
          <p>如果一个 Promise 处于已处理状态，在这之后添加到任务队列中的处理程序仍将执行。所以无论什么时候你都可以添加新的完成处理程序或拒绝处理程序，同时也可以保证这些处理程序能被调用。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">readFile</span><span class="p">(</span><span class="s2">"example.txt"</span><span class="p">);</span>
      
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 完成</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
          
    <span class="c1">// 现在又添加一个</span>
    <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
       <span class="c1">// 完成</span>
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>        </div>
        <blockquote>
          <p>每次调用 then() 方法或 catch() 方法都会创建一个新任务，当 Promise 被解决（resolved）时执行。这些任务最终会被加入到一个为Promise量身定制的独立队列中，这个任务队列的具体细节对于理解如何使用Promise而言并不重要，通常你只需要知道任务队列是如何运行的就可以了。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>创建未完成的 Promise</p>

    <blockquote>
      <p>用Promise 构造函数创建新的 Promise，构造函数只接受一个参数：包含初始化 Promise 代码的执行器（executor）函数。执行器接受两个参数，分别是 resolve() 函数和 reject() 函数。执行器成功完成时调用 resolve() 函数，反之，失败时则调用 reject() 函数。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>
    
<span class="kd">function</span> <span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// function 即为执行器</span>
        
    <span class="c1">// 触发异步操作</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="p">{</span><span class="na">encoding</span><span class="p">:</span> <span class="s2">"utf-8"</span><span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 检查是否有错误</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
          
      <span class="c1">// 成功读取文件</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
    
<span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">readFile</span><span class="p">(</span><span class="s2">"example.txt"</span><span class="p">);</span>
    
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 完成</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">contents</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 拒绝</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>    </div>
    <blockquote>
      <p>readFile() 方法被调用时执行器会立即执行，在执行器中，无论是调用 resolve() 还是 reject() ，都会向任务队列中添加一个任务来解决这个Promise。Promise 具有类似setTimeout的工作原理，Promise 的执行器会立即执行，然后才执行后续流程中的代码。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Promise"</span><span class="p">);</span>
  <span class="nx">resolve</span><span class="p">();</span>
<span class="p">});</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hi"</span><span class="p">);</span>
    
<span class="c1">// 输出</span>
<span class="c1">// Promise</span>
<span class="c1">// Hi</span>
</code></pre></div>    </div>

    <blockquote>
      <p>调用 resolve() 后会触发一个异步操作，传入then() 和 catch() 方法的函数会被添加到任务队列中并异步执行。不管then() 和 catch() 在代码中的位置如何，它们都不会立即执行，这是因为完成处理程序和拒绝处理程序总是在执行器完成后被添加到任务队列的末尾。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Promise"</span><span class="p">);</span>
  <span class="nx">resolve</span><span class="p">();</span>
<span class="p">});</span>
    
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Resolved."</span><span class="p">);</span>
<span class="p">});</span>
    
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hi"</span><span class="p">);</span>
    
<span class="c1">// 输出</span>
<span class="c1">// Promise</span>
<span class="c1">// Hi</span>
<span class="c1">// Resolved.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>创建已处理的 Promise</p>

    <blockquote>
      <p>创建未处理Promise 的最好方法是使用 Promise的构造函数，这是由于 Promise 执行器具有动态性。但如果你想用 Promise 来表示一个已知的值，则编排一个只是简单地给 resolve() 函数传值的任务并无实际意义，反倒是可以采用以下两种方式根据特定的值来创建已解决的 Promise。</p>
    </blockquote>

    <ul>
      <li>
        <p>使用 Promise.resolve() 创建一个已完成的 Promise</p>
      </li>
      <li>
        <p>使用 Promise.reject() 创建一个已拒绝的 Promise</p>
      </li>
    </ul>

    <blockquote>
      <p>Promise.resolve() 和 Promise.reject() 方法很像，它们都只接受一个参数并返回一个已处理的 Promise，无非一个是已完成状态一个是已拒绝状态。也就是说直接调用这两个方法返回的Promise不会有任务编排的过程，并且需要向 Promise 添加一至多个处理程序来获取值。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
  <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>  <span class="c1">// 42</span>
  <span class="p">});</span>
    
  <span class="kd">let</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
  <span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>  <span class="c1">// 42</span>
  <span class="p">});</span>
</code></pre></div>    </div>

    <blockquote>
      <p>Promise.resolve() 返回的Promise只会调用then()方法，永远不会调用catch() 方法，反之， Promise.reject() 返回的Promise只会调用 catch() 方法，永远不会调用 then() 方法。如果向 Promise.resolve() 或者 Promise.reject() 中传入一个Promise，这个 Promise 会直接被返回出去。</p>
    </blockquote>

    <ul>
      <li>非 Promise 的 Thenable 对象</li>
    </ul>

    <blockquote>
      <p>Promise.resolve() 方法和 Promise.reject() 方法都可以接受非 Promise 的 Thenable 对象作为参数。如果传入一个非 Promise 的 Thenable 对象，则这些方法会创建一个新的 Promise，并在 then() 函数中被调用。</p>
    </blockquote>

    <blockquote>
      <p>拥有 then() 方法并且接受 resolve 和 reject 这两个参数的普通对象就是非 Promise 的 Thenable 对象。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 已完成</span>
  <span class="kd">let</span> <span class="nx">thenable</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">then</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
    
  <span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">thenable</span><span class="p">);</span>
      
  <span class="nx">p1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 42</span>
  <span class="p">});</span>
    
  <span class="c1">// 已拒绝</span>
  <span class="kd">let</span> <span class="nx">thenable2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">then</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
    
  <span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">thenable</span><span class="p">);</span>
      
  <span class="nx">p2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 42</span>
  <span class="p">});</span>
</code></pre></div>    </div>
    <blockquote>
      <p>有了 Promise.resolve() 方法和 Promise.reject() 方法，我们可以更轻松地处理非 Promise 的 Thenable 对象。在ES6引入 Promise 对象之前，许多库都使用了 Thenable 对象，所以如果要向后兼容之前已有的库，则将 Thenable 对象转换成正式的 Promise 的能力就显得至关重要了。如果不确定某个对象是不是 Promise 对象，那么可以根据预期的结果将其传入 Promise.resolve() 方法或者 Promise.reject() 方法中，如果它是 Promise 对象，则不会有任何变化。</p>
    </blockquote>
  </li>
  <li>
    <p>执行器错误</p>

    <blockquote>
      <p>如果执行器内部抛出一个错误，则 Promise 的拒绝处理程序就会被调用。</p>
    </blockquote>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Explosion!"</span><span class="p">);</span>
<span class="p">});</span>
    
<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// "Explosion!"</span>
<span class="p">});</span>
    
<span class="c1">// 等价于如下代码</span>
    
<span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span><span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Explosion!"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
    
<span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// "Explosion!"</span>
<span class="p">});</span>    
</code></pre></div>    </div>
    <blockquote>
      <p>为了简化这种常见的用例，执行器会捕获所有抛出的错误，但只有当拒绝处理程序存在时才会记录执行器中抛出的错误，否则错误会被忽略掉。在早期的时候，开发者使用Promise的时候会遇到这样的问题，后来JS环境提供了一些捕获已拒绝 Promise 的钩子函数来解决这个问题。</p>
    </blockquote>
  </li>
  <li>
    <p>全局的 Promise 拒绝处理</p>

    <blockquote>
      <p>有关 Promise 的其中一个最具争议性的问题是，如果在没有拒绝处理程序的情况下拒绝一个 Promise，那么不会提示失败信息，这是JavaScript语言中唯一一处没有强制报错的地方，一些人认为这是标准中最大的缺陷。因为任何时候都可以调用 then() 方法或 catch() 方法，无论 Promise 是否已解决这两个方法都能正常运行，但这样就很难知道一个 Promise 何时被处理。尽管这个问题在未来的ECMAScript标准中可能会被解决，但是Node.js 和浏览器环境都已经分别做出了一些改变来解决开发者的这个痛点，这些改变不是 ES6 标准的一部分，但是当你使用 Promise 的时候它们确实是非常有价值的工具。</p>
    </blockquote>

    <ul>
      <li>
        <p>Node.js 环境的拒绝处理</p>

        <blockquote>
          <p>在Node.js 中，处理Promise拒绝时会触发 process 对象上的两个事件：</p>
        </blockquote>

        <ul>
          <li>
            <p>unhandledRejection 在一个事件循环中，当 Promise 被拒绝，并且没有提供拒绝处理程序时被调用。</p>
          </li>
          <li>
            <p>rejectionHandled 在一个事件循环后，当 Promise 被拒绝，并且没有提供拒绝处理程序时被调用。</p>
          </li>
        </ul>

        <blockquote>
          <p>设计这些事件是用来识别那些被拒绝却又没被处理过的 Promise 的。拒绝原因（通常是一个错误对象）及被拒绝的 Promise 作为参数被传入 unhandledRejection 事件处理程序中。事件处理程序分别接受错误对象和 Promise 作为它的两个参数。而rejectionHandled 事件处理程序只接受一个参数，那就是被拒绝的 Promise。</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">rejected</span><span class="p">;</span>
    
<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"unhandledRejection"</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>        <span class="c1">// "Explosion!"</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rejected</span> <span class="o">===</span> <span class="nx">promise</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="p">});</span>
    
<span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Explosion!"</span><span class="p">));</span>
    
<span class="kd">let</span> <span class="nx">rejected2</span><span class="p">;</span>
    
<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"rejectionHandled"</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rejected</span> <span class="o">===</span> <span class="nx">promise</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="p">});</span>
    
<span class="nx">rejected2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Explosion!"</span><span class="p">));</span>    
    
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">rejected2</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>  <span class="c1">// "Explosion!"</span>
  <span class="p">});</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div>        </div>
        <blockquote>
          <p>这里的 rejectionHandled 事件在拒绝处理程序最后被调用时触发，如果在创建 rejected 之后直接添加拒绝处理程序，那么 rejectionHandled 事件不会被触发，因为 rejected 创建的过程与拒绝处理程序的调用在同一个时间循环中，此时 rejectionHandled 事件尚未生效。</p>
        </blockquote>

        <blockquote>
          <p>通过事件 rejectionHandled 和事件 unhandledRejection 将潜在未处理的拒绝存储为一个列表，等待一段时间后检查列表便能够正确地跟踪潜在的未处理拒绝，我们可以使用如下代码来实现一个简单的未处理拒绝跟踪器：</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">possiblyUnhandledRejection</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    
<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"unhandledRejection"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">reason</span><span class="p">);</span>
<span class="p">});</span>
    
<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"handledRejection"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">promise</span><span class="p">);</span>
<span class="p">});</span>
    
<span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">.</span><span class="nx">message</span> <span class="p">?</span> <span class="nx">reason</span><span class="p">.</span><span class="nx">message</span> <span class="p">:</span> <span class="nx">reason</span><span class="p">);</span>
    
    <span class="c1">// 处理这些拒绝</span>
    <span class="nx">handleRejection</span><span class="p">(</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">reason</span><span class="p">);</span>
  <span class="p">});</span>
    
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
<span class="p">},</span> <span class="mi">60000</span><span class="p">);</span>
    
</code></pre></div>        </div>
        <blockquote>
          <p>这里使用的是Map集合而不是WeakMap集合，因为你要定期检查集合中一个Promise是否存在，WeakMap无法实现。</p>
        </blockquote>
      </li>
      <li>
        <p>浏览器环境的拒绝处理</p>

        <blockquote>
          <p>浏览器也是通过触发两个事件来识别未处理的拒绝的，虽然这些事件是在 window 对象上触发的，但实际上与 Node.js 中的完全等效。</p>
        </blockquote>

        <ul>
          <li>
            <p>unhandledrejection 在一个事件循环中，当 Promise 被拒绝，并且没有提供拒绝处理程序时被调用。</p>
          </li>
          <li>
            <p>rejectionhandled 在一个事件循环后，当 Promise 被拒绝，并且没有提供拒绝处理程序时被调用。</p>
          </li>
        </ul>

        <blockquote>
          <p>与Node.js 环境不同的是，在浏览器中，这两个事件中都可以使用拒绝值（reason），且事件处理程序接受一个有如下三个属性的事件对象作为参数：</p>
        </blockquote>

        <ul>
          <li>
            <p>type 事件名称（”unhandledrejection” 或 “rejectionhandled”）</p>
          </li>
          <li>
            <p>promise 被拒绝的Promise对象</p>
          </li>
          <li>
            <p>reason 来自Promise的拒绝值</p>
          </li>
        </ul>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">rejected</span><span class="p">;</span>
        
  <span class="nb">window</span><span class="p">.</span><span class="nx">onunhandledrejection</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span> <span class="c1">// "unhandledrejection"</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">reason</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// "Explosion!"</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">promise</span> <span class="o">===</span> <span class="nx">rejected</span><span class="p">);</span> <span class="c1">// true</span>
  <span class="p">};</span>
      
  <span class="nb">window</span><span class="p">.</span><span class="nx">onrejectionhandled</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span> <span class="c1">// "rejectionhandled"</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">reason</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// "Explosion!"</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">promise</span> <span class="o">===</span> <span class="nx">rejected</span><span class="p">);</span> <span class="c1">// true</span>
  <span class="p">};</span>
        
  <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Explosion!"</span><span class="p">));</span>
</code></pre></div>        </div>
        <blockquote>
          <p>你也可以使用 addEventListener(“unhandledrejection”) 和 addEventListener(“rejectionhandled”)，每个事件处理程序接受一个含有被拒绝Promise信息的事件对象，该对象的属性type、promise、reason在这两个事件处理程序中均可使用。浏览器中的跟踪未处理拒绝的实现和Node.js中的实现也十分相似：</p>
        </blockquote>

        <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">possiblyUnhandledRejection</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    
<span class="nb">window</span><span class="p">.</span><span class="nx">onunhandledrejection</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
<span class="p">};</span>
    
<span class="nb">window</span><span class="p">.</span><span class="nx">onrejectionhandled</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">promise</span><span class="p">);</span>
<span class="p">};</span>
    
<span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">.</span><span class="nx">message</span> <span class="p">?</span> <span class="nx">reason</span><span class="p">.</span><span class="nx">message</span> <span class="p">:</span> <span class="nx">reason</span><span class="p">);</span>
    
    <span class="c1">// 处理这些拒绝</span>
    <span class="nx">handleRejection</span><span class="p">(</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">reason</span><span class="p">);</span>
  <span class="p">});</span>
    
  <span class="nx">possiblyUnhandledRejection</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
<span class="p">},</span> <span class="mi">60000</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3>3. 代理（Proxy）</h3>

</div>
    </div>
    <div class="sidebar-list">
        <div class="tag-cloud">
    <ul>
        <li>JavaScript</li>
        <li>Node.js</li>
        <li>Vue</li>
        <li>React</li>
        <li>Koa2</li>
        <li>Webpack</li>
        <li>TypeScript</li>
        <li>Express</li>
    </ul>
</div>
        <div class="search-box">
    <div class="search-holder">
        <input class="search-input" type="text" placeholder="没事别瞎点搜索">
    </div>
</div>
        <div class="blog-author">
    <div class="avatar">
        <img src="/assets/images/avatar/dfyc.jpeg" alt="" width="160">
    </div>
    <ul>
        <li>昵称：lizm</li>
        <li>性别：少年</li>
        <li>生日：1993-03-29</li>
        <li>签名：</li>
        <li>hahaahahhahahahahahaahahhahahaahah</li>
    </ul>
</div>
        <div class="date-picker">
    <link rel="stylesheet" href="/lib/calendar/css/calendar.css">
    <script src="/lib/jquery/jquery-3.4.1.js"></script>
    <script src="/lib/calendar/js/calendar.js"></script>
    <div id="calendar" class="calendar"></div>
</div>
        <div class="hot-posts">

</div>
    </div>
</div>
</body>
</html>